---
title: Performance & Optimization
description: Optimize your DayFlow calendar for production performance
---

# Performance & Optimization

This guide covers best practices for optimizing your DayFlow calendar implementation for production use.

## Bundle Size Optimization

### Tree-Shaking

DayFlow is built with tree-shaking in mind. Import only what you need:

```typescript
// ✅ Good - Import specific functions
import { useCalendarApp, DayFlowCalendar } from '@dayflow/core';
import { createMonthView } from 'dayflow-core/factories';

// ❌ Avoid - Importing everything
import * as DayFlow from '@dayflow/core';
```

### Code Splitting

For large applications, lazy load calendar views:

```typescript
import { lazy, Suspense } from 'react';

const CalendarPage = lazy(() => import('./CalendarPage'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <CalendarPage />
    </Suspense>
  );
}
```

### Bundle Analysis

Analyze your bundle to identify large dependencies:

```bash
# Run production build
npm run build

# Open bundle-analysis.html to see size breakdown
```

**Current Bundle Sizes:**
- ESM bundle: ~237KB (minified)
- Gzipped: ~65KB
- Main dependencies: `temporal-polyfill` (58KB), `lucide-react` icons

### Reducing Bundle Size

#### 1. Use Specific Icon Imports

```typescript
// ❌ Large - Imports all icons
import { Calendar, Clock, User } from 'lucide-react';

// ✅ Smaller - Import only what you need
import Calendar from 'lucide-react/dist/esm/icons/calendar';
import Clock from 'lucide-react/dist/esm/icons/clock';
```

#### 2. Optimize Dependencies

The package uses optimized imports internally:

```typescript
// ✅ Already optimized in DayFlow
import throttle from 'lodash/throttle';  // Not full lodash
```

## Runtime Performance

### Event Optimization

#### Pagination for Large Event Sets

```typescript
const calendar = useCalendarApp({
  events: filteredEvents, // Filter by date range
  // ... other options
});

// Load events dynamically
useEffect(() => {
  const visibleRange = calendar.app.getVisibleDateRange();
  loadEvents(visibleRange.start, visibleRange.end);
}, [calendar.app.state.currentDate]);
```

#### Memoize Event Calculations

```typescript
const processedEvents = useMemo(() => {
  return events.map(event => ({
    ...event,
    // expensive calculations
  }));
}, [events]);
```

### View Performance

#### Virtual Scrolling

Month view uses virtual scrolling by default for optimal performance with 1000+ weeks.

Configuration:
```typescript
const monthView = createMonthView({
  virtualScrollConfig: {
    initialWeeks: 156,  // ~3 years
    bufferWeeks: 52,    // 1 year buffer
  },
});
```

#### Debounce Updates

```typescript
import { useMemo } from 'react';
import debounce from 'lodash/debounce';

const debouncedUpdate = useMemo(
  () => debounce((event) => {
    calendar.app.updateEvent(event.id, event);
  }, 300),
  []
);
```

### Drag Performance

Drag operations are throttled by default:

```typescript
// Week/Day views: 8ms throttle (~120fps)
// Month view: 16ms throttle (~60fps)
```

Custom throttling:
```typescript
const dragPlugin = createDragPlugin({
  enableDrag: true,
  // Adjust throttle in useDragState if needed
});
```

## Memory Optimization

### Cleanup Event Listeners

```typescript
useEffect(() => {
  const handler = (e) => { /* ... */ };
  element.addEventListener('mousedown', handler);

  return () => {
    element.removeEventListener('mousedown', handler);
  };
}, []);
```

### Avoid Memory Leaks

```typescript
// ✅ Good - Cleanup callback
const calendar = useCalendarApp({
  events,
  onEventCreate: (event) => {
    // No subscriptions or timers here
  },
});

// ❌ Bad - Memory leak
const calendar = useCalendarApp({
  events,
  onEventCreate: (event) => {
    setInterval(() => {
      console.log(event); // Leaks memory
    }, 1000);
  },
});
```

## Rendering Optimization

### React.memo for Custom Components

```typescript
import { memo } from 'react';

const CustomEventContent = memo(({ event }) => {
  return (
    <div>
      <h3>{event.title}</h3>
      <p>{event.description}</p>
    </div>
  );
});
```

### useCallback for Handlers

```typescript
const handleEventClick = useCallback((event) => {
  // Handler logic
}, [/* dependencies */]);

<DayFlowCalendar
  calendar={calendar}
  customDetailPanelContent={handleEventClick}
/>
```

### Optimize Re-renders

```typescript
// ✅ Good - Memoized props
const memoizedConfig = useMemo(() => ({
  enableDrag: true,
  enableResize: true,
}), []);

const dragPlugin = createDragPlugin(memoizedConfig);

// ❌ Bad - New object every render
const dragPlugin = createDragPlugin({
  enableDrag: true, // Creates new config object
});
```

## Production Checklist

### Before Deployment

- [ ] Run `npm run build` successfully
- [ ] Check `bundle-analysis.html` for unexpected large dependencies
- [ ] Run `npm test` - all tests passing
- [ ] Check bundle size: `du -sh dist/`
- [ ] Test in production mode: `NODE_ENV=production`
- [ ] Verify no console.log statements in production
- [ ] Enable gzip compression on your server
- [ ] Add proper cache headers for static assets

### Performance Monitoring

```typescript
// Add performance marks
performance.mark('calendar-render-start');

<DayFlowCalendar calendar={calendar} />

performance.mark('calendar-render-end');
performance.measure(
  'calendar-render',
  'calendar-render-start',
  'calendar-render-end'
);
```

## Performance Metrics

### Target Metrics

- **Initial Load**: < 1 second
- **Event Render**: < 100ms for 100 events
- **Drag Response**: < 16ms (60fps)
- **Month Switch**: < 50ms
- **Bundle Size**: < 250KB (minified)

### Measuring Performance

```typescript
// React DevTools Profiler
import { Profiler } from 'react';

<Profiler
  id="Calendar"
  onRender={(id, phase, actualDuration) => {
    console.log(`${id} ${phase}: ${actualDuration}ms`);
  }}
>
  <DayFlowCalendar calendar={calendar} />
</Profiler>
```

## Advanced Optimization

### Web Workers

For heavy event processing:

```typescript
// worker.ts
self.addEventListener('message', (e) => {
  const events = e.data;
  const processed = processEvents(events);
  self.postMessage(processed);
});

// main.ts
const worker = new Worker('worker.ts');
worker.postMessage(events);
worker.onmessage = (e) => {
  setProcessedEvents(e.data);
};
```

### Virtualization for Event Lists

For sidebars with 1000+ events:

```typescript
import { FixedSizeList } from 'react-window';

<FixedSizeList
  height={600}
  itemCount={events.length}
  itemSize={50}
>
  {({ index, style }) => (
    <div style={style}>
      {events[index].title}
    </div>
  )}
</FixedSizeList>
```

### CSS Optimization

```css
/* Use transform for animations (GPU-accelerated) */
.event {
  transform: translateY(0);
  transition: transform 200ms ease;
}

.event:hover {
  transform: translateY(-2px);
}

/* Avoid expensive properties */
/* ❌ Bad */
.event {
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

/* ✅ Better */
.event {
  will-change: transform;
  box-shadow: var(--shadow-sm);
}
```

## Common Performance Issues

### Issue: Slow Initial Render

**Cause**: Too many events loaded at once

**Solution**:
```typescript
// Load only visible range
const visibleEvents = useMemo(() => {
  const start = getCurrentWeekStart();
  const end = getCurrentWeekEnd();
  return events.filter(e =>
    isEventInRange(e, start, end)
  );
}, [events, currentDate]);
```

### Issue: Sluggish Drag

**Cause**: Too many re-renders during drag

**Solution**:
```typescript
// Use refs for intermediate state
const dragRef = useRef({ x: 0, y: 0 });

// Update DOM directly during drag
const handleDrag = (e) => {
  dragRef.current = { x: e.clientX, y: e.clientY };
  requestAnimationFrame(() => {
    updateIndicatorPosition(dragRef.current);
  });
};
```

### Issue: Large Bundle Size

**Cause**: Importing unused features

**Solution**:
- Check `bundle-analysis.html`
- Use dynamic imports for optional features
- Remove unused plugins

## Next Steps

- [Testing Guide](/docs/testing)
- [Bundle Analysis Tool](https://github.com/btd/rollup-plugin-visualizer)
- [React Performance Profiling](https://react.dev/learn/react-developer-tools#profiler)
